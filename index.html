<!DOCTYPE html>
<html>
<head>
  <title>Andres Circle Algorithm (an arc implementation by Motla)</title>
</head>
<body style="font-family: sans-serif">

  <canvas id="canvas" width="200" height="200" style="border: solid 1px grey"></canvas>

  <form>
    <div><label><input id="center_x" type="range" min="0" max="200" value="100" oninput="this.nextElementSibling.value = this.value; update_arc();"><input type="number" min="0" max="200" value="100" oninput="this.previousElementSibling.value = this.value; update_arc();"> : center_x</label></div>
    <div><label><input id="center_y" type="range" min="0" max="200" value="100" oninput="this.nextElementSibling.value = this.value; update_arc();"><input type="number" min="0" max="200" value="100" oninput="this.previousElementSibling.value = this.value; update_arc();"> : center_y</label></div>
    <div><label><input id="inner_radius" type="range" min="0" max="150" value="35" oninput="this.nextElementSibling.value = this.value; update_arc();"><input type="number" min="0" max="150" value="35" oninput="this.previousElementSibling.value = this.value; update_arc();"> : inner_radius</label></div>
    <div><label><input id="outer_radius" type="range" min="0" max="150" value="40" oninput="this.nextElementSibling.value = this.value; update_arc();"><input type="number" min="0" max="150" value="40" oninput="this.previousElementSibling.value = this.value; update_arc();"> : outer_radius</label></div>
    <div><label><input id="angle_start" type="range" min="0" max="360" value="0" oninput="this.nextElementSibling.value = this.value; update_arc();"><input type="number" min="0" max="360" value="0" oninput="this.previousElementSibling.value = this.value; update_arc();"> : angle_start</label></div>
    <div><label><input id="angle_end" type="range" min="0" max="360" value="300" oninput="this.nextElementSibling.value = this.value; update_arc();"><input type="number" min="0" max="360" value="300" oninput="this.previousElementSibling.value = this.value; update_arc();"> : angle_end</label></div>
    <div>
      <label><input id="offset" name="offset" type="range" min="0" max="360" value="0" oninput="this.nextElementSibling.value = this.value; update_arc();"><input type="number" name="offset2" min="0" max="360" value="0" oninput="this.previousElementSibling.value = this.value; update_arc();"> : (percent offset)</label>
      <label><input type="checkbox" onclick="if(this.checked) this.itv = setInterval(() => { document.forms[0].offset.value = document.forms[0].offset2.value = (parseInt(document.forms[0].offset.value) + 5) % 360; update_arc(); }, 20); else clearInterval(this.itv)">Animate</label>
    </div>
    <div><label><input id="fast_approx" type="checkbox" onchange="update_arc()" checked> Fast approximation (no float, no trigonometric)</label></div>
  </form>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");


    function drawArc(center_x, center_y, inner_radius, outer_radius, angle_start, angle_end, atan2f) {
      // Declare variables
      const M_PI_2 = 1.57079632679489661923;
      const M_PI_4 = 0.78539816339744830962;
      let x, y, d, r, cnt, num_pts, as, ae; // int

      // Manage angle inputs
      if(angle_start == angle_end) return;
      let inverted = (angle_start > angle_end);
      as = inverted ? angle_end : angle_start;
      ae = inverted ? angle_start : angle_end;

      // Trace each arc radius with Andres circle algorithm
      for(r = inner_radius; r <= outer_radius; r++) {
        x = 0;
        y = r;
        d = r - 1;
        cnt = -1;
        num_pts = atan2f ? 100 : r * 8 / 10; // if no atan2f() function is provided, we make a low cost approximation for the number of pixels drawn on 1/8th circle of radius r
        
        while (y >= x) {
          // If atan2f() function is provided, get the percentage of 1/8th circle drawn, otherwise count the drawn pixels
          if(atan2f) cnt = parseInt((M_PI_2 - atan2f(y, x)) / M_PI_4 * 100);
          else cnt++;

          // Fill the pixels of the 8 sections of the circle, only on the arc defined by the angles (start and end)
          if((cnt >= num_pts * as / 45 && cnt <= num_pts * ae / 45) ^ inverted) ctx.fillRect(center_x + y, center_y - x, 1, 1);
          if((cnt >= num_pts * (90 - ae) / 45 && cnt <= num_pts * (90 - as) / 45) ^ inverted) ctx.fillRect(center_x + x, center_y - y, 1, 1);
          if((cnt >= num_pts * (as - 90) / 45 && cnt <= num_pts * (ae - 90) / 45) ^ inverted) ctx.fillRect(center_x - x, center_y - y, 1, 1);
          if((cnt >= num_pts * (180 - ae) / 45 && cnt <= num_pts * (180 - as) / 45) ^ inverted) ctx.fillRect(center_x - y, center_y - x, 1, 1);
          if((cnt >= num_pts * (as - 180) / 45 && cnt <= num_pts * (ae - 180) / 45) ^ inverted) ctx.fillRect(center_x - y, center_y + x, 1, 1);
          if((cnt >= num_pts * (270 - ae) / 45 && cnt <= num_pts * (270 - as) / 45) ^ inverted) ctx.fillRect(center_x - x, center_y + y, 1, 1);
          if((cnt >= num_pts * (as - 270) / 45 && cnt <= num_pts * (ae - 270) / 45) ^ inverted) ctx.fillRect(center_x + x, center_y + y, 1, 1);
          if((cnt >= num_pts * (360 - ae) / 45 && cnt <= num_pts * (360 - as) / 45) ^ inverted) ctx.fillRect(center_x + y, center_y + x, 1, 1);

          // Process Andres circle algorithm
          if (d >= 2 * x) {
            d = d - 2 * x - 1;
            x = x + 1;
          } else if (d < 2 * (r - y)) {
            d = d + 2 * y - 1;
            y = y - 1;
          } else {
            d = d + 2 * (y - x - 1);
            y = y - 1;
            x = x + 1;
          }
        }
      }
    }


    function update_arc() {
      const center_x = parseInt(document.forms[0].center_x.value);
      const center_y = parseInt(document.forms[0].center_y.value);
      const inner_radius = parseInt(document.forms[0].inner_radius.value);
      const outer_radius = parseInt(document.forms[0].outer_radius.value);
      const angle_start = (parseInt(document.forms[0].angle_start.value) + parseInt(document.forms[0].offset.value)) % 361;
      const angle_end = (parseInt(document.forms[0].angle_end.value) + parseInt(document.forms[0].offset.value)) % 361;
      const fast_approx = document.forms[0].fast_approx.checked;

      // Clear canvas and set color for the arc
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "black";

      // Draw arc
      drawArc(center_x, center_y, inner_radius, outer_radius, angle_start, angle_end, fast_approx ? null : Math.atan2);
    }

    // Initialize arc
    update_arc();
  </script>

</body>
</html>